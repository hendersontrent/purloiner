---
title: "Introduction to purloiner"
author: "Trent Henderson"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Introduction to purloiner}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.height = 7,
  fig.width = 7,
  warning = FALSE,
  fig.align = "center"
)
```

```{r setup, message = FALSE, warning = FALSE}
library(purloiner)
```

## Purpose

`purloiner` consolidates and calculates different sets of time-series features from multiple feature sets in R and Python. While feature extraction in and of itself is useful, users should consider using the larger [`theft`](https://github.com/hendersontrent/theft/tree/main) (Tools for Handling Extraction of Features from Time series) package on CRAN for access to an entire workflow of functions for feature calculation, processing, visualisation, and statistical analysis. `purloiner` is the feature calculation module of `theft`.

## Core calculation functions

To explore package functionality, we are going to calculate features for a basic dataset with 2 time series: one generated by Gaussian noise and the other generated from an AR(1) process:

```{r, message = FALSE, warning = FALSE}
tmp <- data.frame(values = c(rnorm(100), arima.sim(model = list(ar = 0.8), n = 100)))
tmp$id <- rep(c(1, 2), each = 100)
tmp$group <- rep(c("Noise", "AR(1)"), each = 100)
tmp$timepoint <- rep(seq.int(from = 1, to = 100, by = 1), times = 2)
```

### Calculating feature summary statistics

The core function that automates the calculation of the feature statistics at once is `extract_features`. You can choose which subset of features to calculate with the `feature_set` argument. The choices are currently `"catch22"`, `"feasts"`, `"basicproperties"`, `"Kats"`, `"tsfeatures"`, `"tsfresh"`, and/or `"TSFEL"`.

Note that `Kats`, `tsfresh` and `TSFEL` are Python packages. The R package `reticulate` is used to call Python code that uses these packages and applies it within the broader *tidy* data philosophy embodied by `purloiner`. At present, depending on the input time-series, `purloiner` provides access to $>1200$ features.

#### Installing Python feature sets

Prior to using `purloiner` (only if you want to use the `Kats`, `tsfresh` or `TSFEL` feature sets; the R-based sets will run fine) you should have a working Python 3.9 installation and run the function `install_python_libs(python_path, path)` after first installing `purloiner`, where the `python_path` argument is the filepath to the location of Python 3.9 on your machine and the `path` argument is the location you wish to install the Python libraries and virtual environment to on your machine.

For example, if you wanted to install the Python libraries and the resulting virtual environment in `"C:/Users/User/Desktop/purloiner"` and Python 3.9 is located at `"/usr/bin/python"` on your machine, you would run the following after first having installed `purloiner`:

```{r, eval = FALSE}
install_python_libs("C:/Users/User/Desktop/purloiner", "/usr/bin/python")
```

If you want to use any of the Python-based packages, you must first tell R which Python and/or virtual environment on your computer contains the installed libraries. This can be done in `purloiner` via the `init_purloin` function, which has two arguments:

1. `python_path` -- the filepath to the version of Python you wish to use (i.e., the same as was entered into `install_python_libs` if you ran that first)
2. `venv_path` -- the filepath to the Python virtual environment where `tsfresh`, `TSFEL`, and/or `Kats` are installed (i.e., the path returned in the console message from `install_python_libs` if you ran that function first)

However, you do not necessarily have to use this convenience function. If you have another method for pointing R to the correct Python (such as `reticulate` or `findpython`), you can use those in your workflow instead.

**NOTE: You only need to call ** `init_purloin` **or your other solution once per session.**

#### Calculating features

You are then ready to use the rest of the package's functionality, beginning with the extraction of time-series features. `extract_features` takes the following arguments: 

* `data`---data.frame with at least 3 columns: id variable, time variable, value variable
* `id_var`--- character specifying the ID variable to identify each time series. Defaults to `"id"`
* `time_var`---character specifying the time index variable. Defaults to `"timepoint"`
* `values_var`---character specifying the values variable. Defaults to `"values"`
* `group_var`---character specifying the grouping variable that each unique series sits under (if one exists). Defaults to `NULL`
* `feature_set`---character or vector of characters denoting the set of time-series features to calculate. Defaults to `"catch22"`
* `catch24`---Boolean specifying whether to compute `catch24` in addition to `catch22` if `catch22` is one of the feature sets selected. Defaults to `FALSE`
* `tsfresh_cleanup`---Boolean specifying whether to use the in-built `tsfresh` relevant feature filter or not. Defaults to `FALSE`
* `seed`---integer denoting a fixed number for R's random number generator to ensure reproducibility. Defaults to `123`

Here is an example with the `catch22` and `basicproperties` sets:

```{r, message = FALSE, warning = FALSE}
feature_matrix <- extract_features(data = tmp,
                                   id_var = "id",
                                   time_var = "timepoint",
                                   values_var = "values",
                                   group_var = "group",
                                   feature_set = c("catch22", "basicproperties"),
                                   seed = 123)

head(feature_matrix)
```

Note that for the `catch22` set you can set the additional `catch24` argument to calculate the mean and standard deviation in addition to the standard 22 features:

```{r, message = FALSE, warning = FALSE, eval = FALSE}
feature_matrix <- extract_features(data = tmp,
                                   id_var = "id",
                                   time_var = "timepoint",
                                   values_var = "values",
                                   group_var = "group",
                                   feature_set = c("catch22", "basicproperties"),
                                   catch24 = TRUE,
                                   seed = 123)
```

NOTE: If using the `tsfresh` feature set, you might want to consider the `tsfresh_cleanup` argument to `extract_features`. This argument defaults to `FALSE` and specifies whether to use the in-built `tsfresh` relevant feature filter or not.

### Comparison of feature sets

For a comprehensive comparison of `catch22`, `feasts`, `tsfeatures`, `Kats`, `tsfresh`, and `TSFEL` across a range of domains (including computation speed, within-set feature composition, and between-set feature correlations), please refer to the paper [An Empirical Evaluation of Time-Series Feature Sets](https://ieeexplore.ieee.org/document/9679937)^[T. Henderson and B. D. Fulcher, "An Empirical Evaluation of Time-Series Feature Sets," 2021 International Conference on Data Mining Workshops (ICDMW), 2021, pp. 1032-1038, doi: 10.1109/ICDMW53433.2021.00134.].
